### 项目一期 & 二期;请求使用的变化
    一期:
         基于axios封装了普通的请求;使请求变的配置化
    二期:
         又考虑了跨域问题 & 考虑了token的问题


### 项目一期 & 二期;仓库使用的变化
    一期:
        没有给仓库分模块
    二期:
        分模块的去设计仓库


### 项目一期 & 二期;路由使用的变化
    一期:
        普通路由 & 声明式导航
    二期:
        普通路由 嵌套路由 动态路由
        编程式导航
        路由元信息 路由懒加载 路由守卫 keep-alive 路由跳转两种模式(hash history 配404)


### 路由守卫
    全局;路由独享;组件
        导航被触发。
        在失活的组件里调用离开守卫。
        调用全局的 beforeEach 守卫。
        在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
        在路由配置里调用 beforeEnter。
        解析异步路由组件。
        在被激活的组件里调用 beforeRouteEnter。
        调用全局的 beforeResolve 守卫 (2.5+)。
        导航被确认。
        调用全局的 afterEach 钩子。
        触发 DOM 更新。
        用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数

### vuex仓库分模块的写法
        需要注意组件读取仓库数据会发生改变
            store.state.分仓库的名字.数据名

            computed:{
                //key 组件上使用时的名字
                //state 总仓库中的state
                ...mapState({key:state => state.分仓库的名字.数据名})
            }


### vue数据双向绑定的源码
    数据代理
        给vm实例对象 绑上和配置项中的data一模一样的属性;
        我们每一次对vm上属性的读取;本质上是对data中的属性进行了读取
    数据劫持(实现了深度遍历)
        将data中的属性 一个一个拿出来进行了重新定义;是他们的属性具有了
        set和get方法;以后每一次对data中属性进行访问时;执行的都是属性所
        对应的set get方法